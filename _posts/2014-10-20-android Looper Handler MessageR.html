<!DOCTYPE html>
<html>
<head>
<title>android Looper Handler Message</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h2>Handler</h2>

<blockquote>
  <p>A Handler allows you to send and process Message and Runnable objects associated with a thread's MessageQueue. Each Handler instance is associated with a single thread and that thread's message queue. When you create a new Handler, it is bound to the thread / message queue of the thread that is creating it -- from that point on, it will deliver messages and runnables to that message queue and execute them as they come out of the message queue.</p>
</blockquote>

<p>看官网的这段文字，得到几点信息：</p>

<ol>
<li>Handler是用来发送Message或Runnable的</li>
<li>发给MessageQueue，这个MessageQueue是属于Thread的</li>
<li>当你new Handler时，就已经把这个Handler和Thread的MessageQueue绑定了 </li>
<li>发送给message queue的Message或Runnable，当他们出队时，会被执行。</li>
</ol>

<p>奇怪的是，MessageQueue是属于Thread的，这个怎么理解？因为第三点
我们来看看Handler的构造函数</p>

<pre><code>程序1：
 public Handler() {
    ...
    mLooper = Looper.myLooper();
    if (mLooper == null) {
        throw new RuntimeException(
            "Can't create handler inside thread that has not called Looper.prepare()");
    }
    mQueue = mLooper.mQueue;
    ...
}
</code></pre>

<p>Looper.myLooper()：</p>

<pre><code>程序2：
static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();
public static Looper myLooper() {
    return sThreadLocal.get();
}
</code></pre>

<p>ThreadLocal这个类是关键，看看</p>

<blockquote>
  <p>Implements a thread-local storage, that is, a variable for which each thread has its own value. All threads share the same ThreadLocal object, but each sees a different value when accessing it, and changes made by one thread do not affect the other threads. The implementation supports null values.</p>
</blockquote>

<p>简单说就是，一个对象了，每一个线程有自己的副本，每一个线程可以有自己的值，通过get() set()来获取值。</p>

<p>这里还没有完，因为第三点说的是Handler和MessageQueue绑定啊，这里只出现了Looper，同时注意到程序1.的以下语句</p>

<pre><code>mLooper = Looper.myLooper();
if (mLooper == null) {
        throw new RuntimeException(
            "Can't create handler inside thread that has not called Looper.prepare()");
    }
</code></pre>

<p>也就是说，在调用<code>mLooper = Looper.myLooper();</code>之前，必须先调用<code>Looper.prepare()</code></p>

<pre><code> public static void prepare() {
    if (sThreadLocal.get() != null) {
        throw new RuntimeException("Only one Looper may be created per thread");
    }
    sThreadLocal.set(new Looper());
}

private Looper() {
    mQueue = new MessageQueue();
    mRun = true;
    mThread = Thread.currentThread();
}
</code></pre>

<p>原来MessageQueue在Looper里面，而且注意到Looper.prepare()是静态的，直接把Looper的实例存到线程相关的变量里面，这样我们就不用自己保存一个引用了，怪不得<code>mLooper = Looper.myLooper();</code>能直接获取一个线程相关的实例。好了，2和3解决了，Handler里面有一个ThreadLocal的Looper，Looper中有MessageQueue.</p>

<p>对于第1和4点，我们先看看Android官网Handler的</p>

<blockquote>
  <p>Scheduling messages is accomplished with the post(Runnable), postAtTime(Runnable, long), postDelayed(Runnable, long), sendEmptyMessage(int), sendMessage(Message), sendMessageAtTime(Message, long), and sendMessageDelayed(Message, long) methods. The post versions allow you to enqueue Runnable objects to be called by the message queue when they are received; the sendMessage versions allow you to enqueue a Message object containing a bundle of data that will be processed by the Handler's handleMessage(Message) method (requiring that you implement a subclass of Handler).</p>
</blockquote>

<p>我们看看sendMessageAtTime这个方法，因为最后sendMessage族的方法，最后都是调用这个</p>

<pre><code> public boolean sendMessageAtTime(Message msg, long uptimeMillis) {
    boolean sent = false;
    MessageQueue queue = mQueue;
    if (queue != null) {
        msg.target = this;
        sent = queue.enqueueMessage(msg, uptimeMillis);
    }
    else {
        RuntimeException e = new RuntimeException(
            this + " sendMessageAtTime() called with no mQueue");
        Log.w("Looper", e.getMessage(), e);
    }
    return sent;
}
</code></pre>

<p>就是把msg放到Looper的MessageQueue中，第1点解决，现在看第4点，怎样执行呢？</p>

<p>看看官网给出的一段关于Handler的程序</p>

<pre><code> class LooperThread extends Thread {
  public Handler mHandler;

  public void run() {
      Looper.prepare();

      mHandler = new Handler() {
          public void handleMessage(Message msg) {
              // process incoming messages here
          }
      };

      Looper.loop();
  }
}
</code></pre>

<p>注意到最后一句<code>Looper.loop();</code></p>

<pre><code>/**
 * Run the message queue in this thread. Be sure to call
 * {@link #quit()} to end the loop.
 */
public static void loop() {
    Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread.");
    }
    MessageQueue queue = me.mQueue;   
    ...
    while (true) {
        Message msg = queue.next(); // might block
        if (msg != null) {
             ...
            msg.target.dispatchMessage(msg);
            ...
            msg.recycle();
        }
    }
}
</code></pre>

<p>关键就是 <code>msg.target.dispatchMessage(msg);</code>这句了，msg.target是一个Handler</p>

<pre><code>/**
 * Handle system messages here.
 */
public void dispatchMessage(Message msg) {
    if (msg.callback != null) {
        handleCallback(msg);
    } else {
        if (mCallback != null) {
            if (mCallback.handleMessage(msg)) {
                return;
            }
        }
        handleMessage(msg);
    }
}

 private final void handleCallback(Message message) {
    message.callback.run();
}

//mCallback就是构造函数Handler(Callback callback)传入来的，没有传就没有了
public interface Callback {
    public boolean handleMessage(Message msg);
}
</code></pre>

<p>最后才调用handleMessage(msg);就是一般我们会覆盖的方法，如：</p>

<pre><code>Handler handler = new Handler(){
        @Override
        public void handleMessage(Message msg) {
            int type = msg.what;
            switch (type) {
            case 0:
                //do sth
                break;
            case 1:
                //do sth
                break;
            default:
                break;
            }
        }
    };      
</code></pre>

<p>至此，Handler的sendMsg和怎么执行已经分析完毕</p>

<h2>HandlerThread</h2>

<p>根据官方文档，说这个是一个</p>

<blockquote>
  <p>Handy class for starting a new thread that has a looper. The looper can then be used to create handler classes.</p>
</blockquote>

<p>怎样方便呢？</p>

<p>考虑线程A中创建线程B发消息，B向A发消息；
A中：</p>

<p>上面讲了好多，其实总结原理是很简单的。首先，我们要明白，Handler，Looper，Message，MessageQueue这个机制是为主线程（UI线程建立的），为什么？因为UI线程是一个基于消息机制的线程。就是有消息来的时候，就执行，没消息来的时候，就阻塞。android屏幕的Touch，其他事件的发生，都是通过HAL通知window，window的ViewRoot通过消息机制通知UI线程的。那么基于消息的线程怎样设计？我们不结合android源码，就最一般的java代码简单实现一下</p>

<pre><code>public class MessageBaseThread extends Thread {

    BlockingQueue&lt;Runnable&gt; mRunnableQueue = new ArrayBlockingQueue&lt;Runnable&gt;(10);

    public void sendRunnable(Runnable runnable){
        try {
            mRunnableQueue.put(runnable);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    @Override
    public void run() {
        while(true){
            try {
                Runnable runnable = mRunnableQueue.take();//mRunnableQueue空会//阻塞，知道有新的Runnable放进队列
                runnable.run();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
</code></pre>

<p>够简单吧，就是一个while(true)，和一个会阻塞的BlockingQueue。
那就能理解Looper就是这么一个while(true)机制，MessageQueue就是上面的能阻塞的BlockingQueue。而Message，就是封装了message和Runnable的一个类，Handler就是用来发送Message和处理Message到UI线程的处理类</p>

<h3>AsyncTask</h3>

<p>这个类时怎样做到在doInBackground这个非UI线程，向onProgressUpdate和onPostExecute传入参数的呢？其实是用handler.sendMessage这些方法实现的（具体是Message.sendToTarget）</p>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
