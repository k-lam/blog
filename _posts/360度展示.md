#android下的360度展示


##概述：
电商行业竞争激烈，如果可以360度展示一样商品，那就更加有优势了。在网页端，我们已经看到不少360度展示的事例。那在手机端，怎么做呢？我们希望做一个用户通过滑动手指，就能换个观察角度。

##实现思路：
最直接的方式应该是播放视频，看是视频的最后和开始不能连接起来。所以我们用多张照片切换的方式来做。很明显，照片越多，看起来越连续。
1. 通过转盘（淘宝上能搜索岛），拍一个360度的视频。
2. 截30张图传给手机
3. 在手机通过切换图片的方法，来进行360度显示。

但是遇到问题了。
1. 30张图，800*480的jpg格式，一张有170k左右，30张就快5Mb了。对于用户来说，太大了。
2. android上一次性加载30张图片的话。要大概44M的内存空间！

对于第一个问题，我们的办法是压缩。一般的压缩还不行。考虑到每两张图片之间的相似度极高，我们用视频压缩技术。

对于第二个问题，有两版，第一版是虚拟内存的思路，第二版用显存。

于是，我们的整个流程就变成：

1. 通过转盘（淘宝上能搜索到），拍一个360度的视频
2. 用ffmpeg进行截图，平均间距的取30张照片
3. 通过ffmpeg，把这30张照片压缩成视频
4. 传输到手机端，在手机端把视频解压成图片
5. 用图片的方式进行显示

##实现
###ffmpeg截图 压缩
截图和压缩查看ffmpeg的指令
###解压
源码参考jni/decoder.c下的decode2pixel方法。
java中的封装是orbit/Extractor.java

但是解压出来的是bitmap（pixel），所以需要把bitmap保存回png格式。但是如果decode之后串行地执行格式转换，再保存。在ZTE的测试机上耗时超过10s！如何解决这个问题？在这里直接贴上当时的项目周报：

>1. 经过记录时间，发现用时最多的是在  sws_scale  ,for(rgb转bgr) ,写文件三个操作
2. 分线程，sws_scale一个线程A，for和写文件在一个线程B
3. 上面两个线程同步需要同步等待，耗时比较厉害
4. 把ffmpeg中原来的rgb直接解成bgr，省略掉耗时操作for，直接把ffmpeg的数据赋值给openCV。线程A：sws_scale，线程B：写文件
5. 由于多线程操作，返回java改成回调的通知方式，需要在线程B加上同步（临界区实现）。通过优化，主线程只需要进行一次可能会出现的阻塞。
至此，在ZTE机上测试最优结果是主线程3250ms可以返回，从执行开始到所有文件写入，耗时3365ms。慢的情况可能在4.9-6s之间，而主要耗时的操作在sws_scale。

其中，保存函数写在utils.cpp中

###显示
####version 1 虚拟内存的方法：
源码：

* orbit/V360Show.java
* orbit/BitmapLoop2.java

虚拟内存是参考操作系统虚拟内存的做法。当主存不够用的时候，在硬盘中开辟一块空间出来。主存中放置要用的那部分，未用到的放置硬盘中，当发现主存中没有，就从硬盘中load进来，把不用的从内存中存到硬盘中。

所以我们的做法：在内存中保存n张图片（7张以上），容纳这n张图片的叫窗口（主存）。当向左滑动时，相当于窗口向左滑动，这时应该从硬盘中load一张图片，放在窗口的第一个位置，而窗口最后一张图片删除。

#####BitmapLoop2关键代码分析
入口代码是toRight()和toLeft()两个方法，这两个方法都调用getBitmap2

	public Bitmap getBitmap2(int toward, final Context context) {
		this.toward = toward;
		LoadInfo[] lis = caculateShouldLoad2();
		if (lis != null) {
			for (final LoadInfo li : lis) {
				final int cid = controlID++;
				if (li.toward == 0 || li.getCount() == 0) {
					continue;
				}
				Task.KLTask kl = new KLTask();
				Callable<BitmapWithName[]> callable = new Callable<BitmapWithName[]>() {
					@Override
					public BitmapWithName[] call() throws Exception {
						BitmapWithName[] bs = new BitmapWithName[li.getCount()];
						// 读图片
						String name = "";
						if (-1 == li.toward) {
							for (int i = 0; i != bs.length; i++) {
								name = getName(li.loadIndexs[i]);
								bs[i] = new BitmapWithName(getBitmapFromDisk(
										context, name), name);
							}
						} else if (1 == li.toward) {
							for (int i = 0; i != bs.length; i++) {
								name = getName(li.loadIndexs[i]);
								bs[i] = new BitmapWithName(getBitmapFromDisk(
										context, name), name);
							}
						}
						print(cid + " : " + name + " is loaded in background");
						return bs;
					}
				};
				Task<BitmapWithName[]> task = kl.create(callable);
				tasksManager.add(new LoadTask(task, li, cid));
				kl.exec(Task.BACKGROUND_EXECUTOR);
			}
		}
		int index = showing.get() + toward;
		if (index >= 0 && index < WINDOW_CAPACITY) {
			showing.addAndGet(toward);
			try{
				bitmapWindow.get(index);
			}catch(Exception exception){
				
				Log.e("debug","exception: index:" + index + ",WINDOW_CAPACITY:"+WINDOW_CAPACITY+",size:"+bitmapWindow.size()+",thread id:"+Thread.currentThread().getId());
			}
			print(controlID + " showing:" + showing.get() + ",toward:" + toward
					+ ",l:" + tasksManager.lloadingCount + ",r:"
					+ tasksManager.rloadingCount + " name:"
					+ bitmapWindow.get(index).name);
			return bitmapWindow.get(index).bitmap;
		} else {
			print(controlID + " showing:" + showing.get() + ",toward:" + toward
					+ ",l:" + tasksManager.lloadingCount + ",r:"
					+ tasksManager.rloadingCount + "   nothing show");
			return null;
		}
	}

[源码下载](https://github.com/k-lam/orbit)